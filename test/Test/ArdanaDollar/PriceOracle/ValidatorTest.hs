{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TemplateHaskell #-}

--{-# OPTIONS_GHC -fno-specialise #-}

module Test.ArdanaDollar.PriceOracle.ValidatorTest (priceOracleValidatorRegressionTests, priceOracleValidatorGeneratedTests) where

import Data.Semigroup ((<>))

import ArdanaDollar.PriceOracle.OnChain
import Control.Exception (catch, throwIO)
import Control.Monad.Trans.State
import Data.Kind (Type)
import Data.Map qualified as M
import Hedgehog (MonadGen)
import Hedgehog.Gen qualified as Gen
import Ledger qualified
import Ledger.Crypto (pubKeyHash)
import Ledger.Oracle qualified as Oracle
import Ledger.Scripts (mkValidatorScript)
import PlutusTx qualified
import PlutusTx.Prelude hiding (Semigroup (..), mconcat)
import PlutusTx.UniqueMap qualified as UniqueMap
import System.Exit (ExitCode (..))
import Test.Tasty (defaultMain, testGroup)
import Test.Tasty.Options (OptionSet, setOption)
import Test.Tasty.Plutus.Context
import Test.Tasty.Plutus.Script.Unit
import Test.Tasty.Runners (TestTree (..))
import Wallet.Emulator.Types (knownWallet, walletPubKey)
import Prelude (IO, Show, String, maxBound, minBound, putStrLn, show)

import Test.ArdanaDollar.PriceOracle.OnChain.Model.Constraints
import Test.ArdanaDollar.PriceOracle.OnChain.Model.Gen
import Test.ArdanaDollar.PriceOracle.OnChain.Model.Parameters


priceOracleValidatorGeneratedTests :: IO TestTree
priceOracleValidatorGeneratedTests = genSpaceTreeIO

-- maybe we want some of these
priceOracleValidatorRegressionTests :: TestTree
priceOracleValidatorRegressionTests =
  testGroup
    "Regression Tests"
    []

wrapParametricTest :: NamedTestParameters -> IO ()
wrapParametricTest p =
  let tt = parametricValidatorTest p
   in defaultMain tt
        `catch` ( \e ->
                    case e of
                      ExitSuccess -> return ()
                      _ -> explainExpectedTestResult (parameters p) >> throwIO e
                )

explainExpectedTestResult :: TestParameters -> IO ()
explainExpectedTestResult p =
  case constraintViolations p of
    [] -> putStrLn "\nExpected the validate but got failure\n"
    e ->
      putStrLn $
        "\nExpected validation failure due to the following model constraint violations " <> show e <> "\n"
          <> show p
          <> "\n"

---- The test model domain
--
-- test instances can be generated by generating one of these

nameGeneratedParams :: TestParameters -> NamedTestParameters
nameGeneratedParams tp =
  NamedTestParameters
    { subTreeName = "Generated"
    , testName = "violations: " <> show (constraintViolations tp)
    , parameters = tp
    }

data NamedTestParameters = NamedTestParameters
  { subTreeName :: String
  , testName :: String
  , parameters :: TestParameters
  }
  deriving (Show)

----- generatora
--

-- TODO rejection sampling is super inefficient.
-- I don't recommending upping the sample count...
genSpaceTreeIO :: IO TestTree
genSpaceTreeIO = do
  s <- runSpaceExplorationIO (4,10)
  let nps = nameGeneratedParams <$> flattenSpaceExploration s
  return $ testGroup "Price Oracle Validator Generated Test Space Exploration" $ parametricValidatorTest <$> nps

flattenSpaceExploration :: SpaceExploration -> [TestParameters]
flattenSpaceExploration SpaceExploration {..} = shouldPass <> (snd =<< M.toList singleDimFailures) <> detritus

emptySpaceExploration :: SpaceExploration
emptySpaceExploration = SpaceExploration [] M.empty []

runSpaceExplorationIO :: (Integer,Integer) -> IO SpaceExploration
runSpaceExplorationIO coverage =
  Gen.sample $ execStateT (spaceExploration coverage) emptySpaceExploration

data SpaceExploration = SpaceExploration
  { shouldPass :: [TestParameters]
  , singleDimFailures :: M.Map Constraint [TestParameters]
  , detritus :: [TestParameters]
  }

spaceCovered :: Integer -> SpaceExploration -> Bool
spaceCovered coverage_lb SpaceExploration {..} =
  length shouldPass >= coverage_lb
    && length detritus >= coverage_lb
    && and (hasCoverage singleDimFailures <$> [minBound .. maxBound])
  where
    hasCoverage :: M.Map Constraint [TestParameters] -> Constraint -> Bool
    hasCoverage m c =
      case M.lookup c m of
        Nothing -> False
        Just so -> length so >= coverage_lb

insertPointInSpace :: Integer -> TestParameters -> SpaceExploration -> SpaceExploration
insertPointInSpace coverage_ub p s@SpaceExploration {..} =
  case constraintViolations p of
    [] ->
      if length shouldPass < coverage_ub
        then s {shouldPass = p : shouldPass}
        else s
    [c] -> case M.lookup c singleDimFailures of
      Nothing -> s {singleDimFailures = M.insert c [p] singleDimFailures}
      Just so ->
        if length so < coverage_ub
          then s {singleDimFailures = M.insert c (p : so) singleDimFailures}
          else s
    _ ->
      if length detritus < coverage_ub
        then s {detritus = p : detritus}
        else s

spaceExploration ::
  forall (m :: Type -> Type).
  MonadGen m =>
  (Integer,Integer) ->
  StateT SpaceExploration m ()
spaceExploration coverage = do
  s <- get
  if spaceCovered (fst coverage) s
    then return ()
    else do
      p <- genTestParameters
      put $ insertPointInSpace (snd coverage) p s
      spaceExploration coverage

withExpectedResult :: TestParameters -> String -> TestData 'ForSpending -> ContextBuilder 'ForSpending -> WithScript 'ForSpending ()
withExpectedResult p | null (constraintViolations p) = shouldValidate
withExpectedResult _ = shouldn'tValidate

---- helpers
--

lookupPrivateKey :: Integer -> Ledger.PrivateKey
lookupPrivateKey i = Ledger.knownPrivateKeys !! (i - 1)

-- TODO parameterise/randomise the payload data - shouldn't matter what's in there
modelDatum :: TestDatumParameters -> Oracle.SignedMessage PriceTracking
modelDatum TestDatumParameters {..} =
  Oracle.signMessage (PriceTracking UniqueMap.empty UniqueMap.empty (Ledger.POSIXTime timeStamp)) signedByPrivK
  where
    signedByPrivK :: Ledger.PrivateKey
    signedByPrivK = lookupPrivateKey signedByWallet

modelTestData :: TestParameters -> TestData 'ForSpending
modelTestData TestParameters {..} =
  SpendingTest (modelDatum $ stateDatumValue inputParams) () $ stateTokenValue inputParams

setTimeRangeOpt :: Integer -> Integer -> OptionSet -> OptionSet
setTimeRangeOpt from to =
  setOption
    ( TimeRange
        ( Ledger.Interval
            (Ledger.LowerBound (Ledger.Finite (Ledger.POSIXTime from)) True)
            (Ledger.UpperBound (Ledger.Finite (Ledger.POSIXTime to)) True)
        )
    )

setTimeRangeOption :: TestParameters -> OptionSet -> OptionSet
setTimeRangeOption TestParameters {..} = setTimeRangeOpt timeRangeLowerBound timeRangeUpperBound

transactorSpendingAction :: SpenderParams -> ContextBuilder p -> ContextBuilder p
transactorSpendingAction NoSigner = id
transactorSpendingAction (JustSignedBy signer) =
  (<>) (signedWith $ pubKeyHash $ walletPubKey $ knownWallet signer)
transactorSpendingAction (SignedByWithValue signer value) =
  (<>) (spendsFromPubKeySigned (pubKeyHash $ walletPubKey $ knownWallet signer) value)

scriptOutputAction :: StateUTXOParams -> ContextBuilder p
scriptOutputAction StateUTXOParams {..} =
  output (Output (OwnType . PlutusTx.toBuiltinData $ modelDatum stateDatumValue) stateTokenValue)

---- reification of the test using plutus-extra. mmmmm Tasty!
--

parametricValidatorTest :: NamedTestParameters -> TestTree
parametricValidatorTest ntp@NamedTestParameters {parameters = tp@TestParameters {..}, ..} =
  PlusTestOptions (setTimeRangeOption tp) $
    withValidator subTreeName validator $ do
      withExpectedResult tp testName (modelTestData tp) $
        transactorSpendingAction transactorParams $
          scriptOutputAction outputParams
  where
    ownerPubKey :: Ledger.PubKey
    ownerPubKey = walletPubKey (knownWallet ownerWallet)

    ownerPubKeyHash :: Ledger.PubKeyHash
    ownerPubKeyHash = pubKeyHash ownerPubKey

    params :: OracleValidatorParams
    params = OracleValidatorParams (fst stateNFTCurrency) ownerPubKey ownerPubKeyHash peggedCurrency

    validator :: Ledger.Validator
    validator =
      mkValidatorScript $
        $$(PlutusTx.compile [||go||])
          `PlutusTx.applyCode` oracleCompiledTypedValidator params
      where
        {-# INLINEABLE go #-}
        go ::
          (Oracle.SignedMessage PriceTracking -> () -> Ledger.ScriptContext -> Bool) ->
          (BuiltinData -> BuiltinData -> BuiltinData -> ())
        go = toTestValidator
